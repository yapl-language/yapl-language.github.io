{"version":3,"file":"index.cjs","sources":["../src/markdown/protectYaplPlugin.ts","../src/constants/regex.ts","../src/utils/getPath.ts","../src/utils/evaluateCondition.ts","../src/utils/normalizeList.ts","../src/utils/parseWithObject.ts","../src/renderer.ts","../src/index.ts"],"sourcesContent":["/**\n * Markdown-it plugin to protect YAPL-like syntax from Vue template compilation.\n *\n * It wraps code fences, indented code blocks, and inline code that contain\n * YAPL/Jinja-like delimiters ({{ ... }} or {% ... %}), or that are tagged\n * with a language info string including \"yapl\", in a Vue v-pre container.\n *\n * This prevents Vue (VitePress/VuePress) from trying to parse the contents\n * as JavaScript template expressions.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n// biome-ignore lint/suspicious/noExplicitAny: markdown-it types are not available\nexport function protectYaplPlugin(md: any) {\n\tconst origFence = md.renderer.rules.fence;\n\tconst origCodeBlock = md.renderer.rules.code_block;\n\tconst origCodeInline = md.renderer.rules.code_inline;\n\n\tconst hasYaplDelimiters = (s: string) =>\n\t\ts.includes(\"{{\") || s.includes(\"{%\") || s.includes(\"{#\");\n\tconst looksLikeYapl = (info: string, content: string) =>\n\t\tinfo?.toLowerCase().includes(\"yapl\") || hasYaplDelimiters(content);\n\n\t// Fenced code blocks ```\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.fence = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst info = (token.info || \"\").trim();\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origFence\n\t\t\t? origFence(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn looksLikeYapl(info, content)\n\t\t\t? `<div v-pre>\\n${rendered}\\n</div>\\n`\n\t\t\t: rendered;\n\t};\n\n\t// Indented code blocks (no language info)\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.code_block = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origCodeBlock\n\t\t\t? origCodeBlock(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn hasYaplDelimiters(content)\n\t\t\t? `<div v-pre>\\n${rendered}\\n</div>\\n`\n\t\t\t: rendered;\n\t};\n\n\t// Inline code `...`\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.code_inline = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origCodeInline\n\t\t\t? origCodeInline(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn hasYaplDelimiters(content)\n\t\t\t? `<span v-pre>${rendered}</span>`\n\t\t\t: rendered;\n\t};\n}\n\nexport default protectYaplPlugin;\n","export const EXTENDS_REGEX = /\\{%-?\\s*extends\\s+\"([^\"]+)\"\\s*-?%\\}/;\nexport const MIXIN_REGEX =\n\t/\\{%-?\\s*mixin\\s+((?:\"[^\"]+\"\\s*,\\s*)*\"[^\"]+\")\\s*-?%\\}/g;\nexport const INCLUDE_REGEX =\n\t/\\{%-?\\s*include\\s+\"([^\"]+)\"(?:\\s+with\\s+(\\{[\\s\\S]*?\\}))?\\s*-?%\\}/g;\nexport const BLOCK_REGEX =\n\t/\\{%-?\\s*block\\s+([a-zA-Z0-9_:-]+)\\s*-?%\\}([\\s\\S]*?)\\{%-?\\s*endblock\\s*-?%\\}/g;\nexport const VAR_REGEX =\n\t/\\{\\{-?\\s*([a-zA-Z0-9_.]+)(?:\\s*\\|\\s*default\\((?:\"([^\"]*)\"|'([^']*)')\\))?\\s*-?\\}\\}/g;\nexport const SUPER_REGEX = /\\{\\{-?\\s*super\\(\\s*\\)\\s*-?\\}\\}/g;\n\n// Comments\nexport const COMMENT_REGEX = /\\{#-?[\\s\\S]*?-#\\}|\\{#[\\s\\S]*?#\\}/g;\n\n// If-else control structures\nexport const IF_REGEX =\n\t/\\{%-?\\s*if\\s+([^%]+?)\\s*-?%\\}([\\s\\S]*?)(?:\\{%-?\\s*else\\s*-?%\\}([\\s\\S]*?))?\\{%-?\\s*endif\\s*-?%\\}/g;\n","import type { Vars } from \"..\";\n\nexport default function getPath(obj: Vars, dotted: string): unknown {\n\treturn dotted.split(\".\").reduce<unknown>((acc, key) => {\n\t\tif (\n\t\t\tacc &&\n\t\t\ttypeof acc === \"object\" &&\n\t\t\tkey in (acc as Record<string, unknown>)\n\t\t)\n\t\t\treturn (acc as Record<string, unknown>)[key];\n\t\treturn undefined;\n\t}, obj);\n}\n","import type { Vars } from \"..\";\nimport getPath from \"./getPath\";\n\n/**\n * Evaluates a simple condition expression for if statements.\n * Supports basic comparisons and existence checks.\n *\n * Supported operators:\n * - == (equals)\n * - != (not equals)\n * - is defined (variable exists and is not null/undefined)\n * - is not defined (variable is null/undefined)\n * - is empty (variable is null/undefined/empty string/empty array)\n * - is not empty (variable has a value)\n * - and (logical AND)\n * - or (logical OR)\n *\n * Examples:\n * - user.name == \"John\"\n * - count != 0\n * - user.email is defined\n * - items is not empty\n * - status == \"active\"\n * - user.name is defined and user.name != \"\"\n */\nexport default function evaluateCondition(\n\tcondition: string,\n\tvars: Vars,\n): boolean {\n\tconst trimmed = condition.trim();\n\n\t// Handle logical operators (and, or)\n\tconst andMatch = trimmed.match(/^(.+?)\\s+and\\s+(.+)$/);\n\tif (andMatch) {\n\t\tconst [, leftCondition, rightCondition] = andMatch;\n\t\treturn (\n\t\t\tevaluateCondition(leftCondition.trim(), vars) &&\n\t\t\tevaluateCondition(rightCondition.trim(), vars)\n\t\t);\n\t}\n\n\tconst orMatch = trimmed.match(/^(.+?)\\s+or\\s+(.+)$/);\n\tif (orMatch) {\n\t\tconst [, leftCondition, rightCondition] = orMatch;\n\t\treturn (\n\t\t\tevaluateCondition(leftCondition.trim(), vars) ||\n\t\t\tevaluateCondition(rightCondition.trim(), vars)\n\t\t);\n\t}\n\n\t// Handle \"is defined\" / \"is not defined\"\n\tconst isDefinedMatch = trimmed.match(/^(.+?)\\s+is\\s+(not\\s+)?defined$/);\n\tif (isDefinedMatch) {\n\t\tconst [, varPath, notModifier] = isDefinedMatch;\n\t\tconst value = getPath(vars, varPath.trim());\n\t\tconst isDefined = value !== undefined && value !== null;\n\t\treturn notModifier ? !isDefined : isDefined;\n\t}\n\n\t// Handle \"is empty\" / \"is not empty\"\n\tconst isEmptyMatch = trimmed.match(/^(.+?)\\s+is\\s+(not\\s+)?empty$/);\n\tif (isEmptyMatch) {\n\t\tconst [, varPath, notModifier] = isEmptyMatch;\n\t\tconst value = getPath(vars, varPath.trim());\n\t\tconst isEmpty =\n\t\t\tvalue === undefined ||\n\t\t\tvalue === null ||\n\t\t\tvalue === \"\" ||\n\t\t\t(Array.isArray(value) && value.length === 0) ||\n\t\t\t(typeof value === \"object\" && Object.keys(value).length === 0);\n\t\treturn notModifier ? !isEmpty : isEmpty;\n\t}\n\n\t// Handle equality comparisons (== and !=)\n\tconst comparisonMatch = trimmed.match(/^(.+?)\\s*(==|!=)\\s*(.+)$/);\n\tif (comparisonMatch) {\n\t\tconst [, leftExpr, operator, rightExpr] = comparisonMatch;\n\t\tconst leftValue = parseValue(leftExpr.trim(), vars);\n\t\tconst rightValue = parseValue(rightExpr.trim(), vars);\n\n\t\tif (operator === \"==\") {\n\t\t\treturn leftValue === rightValue;\n\t\t}\n\t\tif (operator === \"!=\") {\n\t\t\treturn leftValue !== rightValue;\n\t\t}\n\t}\n\n\t// Handle simple truthiness check (just a variable name)\n\tconst simpleVarMatch = trimmed.match(/^[a-zA-Z0-9_.]+$/);\n\tif (simpleVarMatch) {\n\t\tconst value = getPath(vars, trimmed);\n\t\treturn Boolean(value);\n\t}\n\n\t// If we can't parse the condition, default to false for safety\n\treturn false;\n}\n\n/**\n * Parse a value expression - could be a variable reference, string literal, number, or boolean\n */\nfunction parseValue(expr: string, vars: Vars): unknown {\n\tconst trimmed = expr.trim();\n\n\t// String literal (quoted)\n\tif (\n\t\t(trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\n\t\t(trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\n\t) {\n\t\treturn trimmed.slice(1, -1);\n\t}\n\n\t// Number literal\n\tif (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n\t\treturn Number(trimmed);\n\t}\n\n\t// Boolean literal\n\tif (trimmed === \"true\") return true;\n\tif (trimmed === \"false\") return false;\n\tif (trimmed === \"null\") return null;\n\n\t// Variable reference\n\treturn getPath(vars, trimmed);\n}\n","export default function normalizeList(listLiteral: string): string[] {\n\t// takes `\"a\", \"b\", \"c\"` or `\"a\"` and returns [\"a\",\"b\",\"c\"]\n\tconst items = listLiteral.match(/\"([^\"]+)\"/g) || [];\n\treturn items.map((s) => s.slice(1, -1));\n}\n","import type { Vars } from \"..\";\nimport getPath from \"./getPath\";\n\nexport default function parseWithObject(\n\tliteral: string,\n\tparentVars: Vars,\n): Vars {\n\t// literal is a JSON-like object with support for bare identifiers as variable references.\n\t// Example: {\"lang\":\"en\",\"name\": user.name, \"flag\": true, \"n\": 3}\n\t// Strategy: tokenize values; if unquoted identifier -> look up in parentVars.\n\ttype Token = { k: string; v: string };\n\tconst tokens: Token[] = [];\n\t// naive parse that handles strings, numbers, booleans, null, identifiers\n\tconst inner = literal.trim().replace(/^\\{|\\}$/g, \"\");\n\tif (!inner.trim()) return {};\n\t// split on commas not inside quotes\n\tconst parts: string[] = [];\n\tlet cur = \"\";\n\tlet inStr: string | null = null;\n\tlet esc = false;\n\tfor (const ch of inner) {\n\t\tif (inStr) {\n\t\t\tif (esc) {\n\t\t\t\tcur += ch;\n\t\t\t\tesc = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === \"\\\\\") {\n\t\t\t\tcur += ch;\n\t\t\t\tesc = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === inStr) {\n\t\t\t\tinStr = null;\n\t\t\t\tcur += ch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcur += ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\tinStr = ch;\n\t\t\tcur += ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === \",\") {\n\t\t\tparts.push(cur.trim());\n\t\t\tcur = \"\";\n\t\t\tcontinue;\n\t\t}\n\t\tcur += ch;\n\t}\n\tif (cur.trim()) parts.push(cur.trim());\n\tfor (const p of parts) {\n\t\tconst m = p.match(/^\\s*(\"?)([A-Za-z0-9_.-]+)\\1\\s*:\\s*(.+)\\s*$/);\n\t\tif (!m) continue;\n\t\tconst key = m[2];\n\t\tconst raw = m[3];\n\t\ttokens.push({ k: key, v: raw });\n\t}\n\tconst out: Vars = {};\n\tfor (const { k, v } of tokens) {\n\t\tconst trimmed = v.trim();\n\t\t// string?\n\t\tif (\n\t\t\t(trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\n\t\t\t(trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\n\t\t) {\n\t\t\tout[k] = trimmed.slice(1, -1);\n\t\t\tcontinue;\n\t\t}\n\t\t// number?\n\t\tif (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n\t\t\tout[k] = Number(trimmed);\n\t\t\tcontinue;\n\t\t}\n\t\t// boolean/null?\n\t\tif (trimmed === \"true\") {\n\t\t\tout[k] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (trimmed === \"false\") {\n\t\t\tout[k] = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (trimmed === \"null\") {\n\t\t\tout[k] = null;\n\t\t\tcontinue;\n\t\t}\n\t\t// identifier -> lookup in parent vars\n\t\tout[k] = getPath(parentVars, trimmed);\n\t}\n\treturn out;\n}\n","export type Vars = Record<string, unknown>;\nimport {\n\tBLOCK_REGEX,\n\tCOMMENT_REGEX,\n\tEXTENDS_REGEX,\n\tINCLUDE_REGEX,\n\tMIXIN_REGEX,\n\tSUPER_REGEX,\n\tVAR_REGEX,\n} from \"./constants/regex\";\nimport evaluateCondition from \"./utils/evaluateCondition\";\nimport getPath from \"./utils/getPath\";\nimport normalizeList from \"./utils/normalizeList\";\nimport parseWithObject from \"./utils/parseWithObject\";\n\nexport interface WhitespaceOptions {\n\ttrimBlocks?: boolean;\n\tlstripBlocks?: boolean;\n\tdedentBlocks?: boolean;\n}\n\nexport interface RendererOptions {\n\tbaseDir?: string;\n\tstrictPaths?: boolean;\n\tmaxDepth?: number;\n\twhitespace?: WhitespaceOptions;\n\t// Optional hooks to resolve and load templates (for includes/extends/mixins)\n\tresolvePath?: (\n\t\ttemplateRef: string,\n\t\tfromDir: string,\n\t\tensureExt: (p: string) => string,\n\t) => string;\n\tloadFile?: (absolutePath: string) => Promise<string>;\n\tensureExtension?: (p: string) => string;\n}\n\nexport interface Prompt {\n\tcontent: string;\n\tusedFiles: string[];\n}\n\ninterface RenderContext {\n\tvars: Vars;\n\tcurrentDir: string;\n\tusedFiles: Set<string>;\n\tdepth: number;\n}\n\ninterface RenderOptionsInternal {\n\tnoExtends?: boolean;\n}\n\n// ---------- Whitespace Control Helpers ----------\n\nfunction dedentText(text: string): string {\n\tconst lines = text\n\t\t.replace(/^\\n/, \"\")\n\t\t.replace(/\\n\\s*$/, \"\")\n\t\t.split(\"\\n\");\n\tconst nonEmptyLines = lines.filter((line) => line.trim().length > 0);\n\tif (nonEmptyLines.length === 0) return text;\n\tconst indentLengths = nonEmptyLines.map((line) => {\n\t\tconst match = line.match(/^[ \\t]*/);\n\t\treturn match ? match[0].length : 0;\n\t});\n\tconst minIndent = Math.min(...indentLengths);\n\treturn lines.map((line) => line.slice(minIndent)).join(\"\\n\");\n}\n\nfunction applyTagTrimming(source: string): string {\n\tlet result = source;\n\t// Variable tags\n\tresult = result.replace(/[ \\t]*\\{\\{-/g, \"{{\");\n\tresult = result.replace(/-\\}\\}[ \\t]*\\r?\\n?/g, \"}}\");\n\t// Control tags\n\tresult = result.replace(/[ \\t]*\\{%-/g, \"{%\");\n\tresult = result.replace(/-%\\}[ \\t]*\\r?\\n?/g, \"%}\");\n\t// Comment tags\n\tresult = result.replace(/[ \\t]*\\{#-/g, \"{#\");\n\tresult = result.replace(/-#\\}[ \\t]*\\r?\\n?/g, \"#}\");\n\treturn result;\n}\n\nfunction applyGlobalWhitespaceControl(\n\tsource: string,\n\toptions: WhitespaceOptions,\n): string {\n\tlet result = source;\n\tif (options.lstripBlocks) {\n\t\tresult = result.replace(/^[ \\t]+(?=\\{%)/gm, \"\");\n\t}\n\tif (options.trimBlocks) {\n\t\tresult = result.replace(/%\\}[ \\t]*\\r?\\n/g, \"%}\");\n\t}\n\treturn result;\n}\n\nexport class YAPLRenderer {\n\tprivate baseDir: string;\n\tprivate strictPaths: boolean;\n\tprivate maxDepth: number;\n\tprivate whitespaceOptions: WhitespaceOptions;\n\tprivate _resolvePath?: RendererOptions[\"resolvePath\"];\n\tprivate _loadFile?: RendererOptions[\"loadFile\"];\n\tprivate _ensureExtension: (p: string) => string;\n\n\t// Public getters for browser compatibility\n\tget loadFile() {\n\t\treturn this._loadFile;\n\t}\n\tget resolvePath() {\n\t\treturn this._resolvePath;\n\t}\n\tget ensureExtension() {\n\t\treturn this._ensureExtension;\n\t}\n\n\tconstructor(opts: RendererOptions = {}) {\n\t\tthis.baseDir = opts.baseDir ? opts.baseDir : \"\";\n\t\tthis.strictPaths = opts.strictPaths !== false;\n\t\tthis.maxDepth = opts.maxDepth ?? 20;\n\t\tthis.whitespaceOptions = {\n\t\t\ttrimBlocks: opts.whitespace?.trimBlocks ?? true,\n\t\t\tlstripBlocks: opts.whitespace?.lstripBlocks ?? true,\n\t\t\tdedentBlocks: opts.whitespace?.dedentBlocks ?? true,\n\t\t};\n\t\tthis._resolvePath = opts.resolvePath;\n\t\tthis._loadFile = opts.loadFile;\n\t\tthis._ensureExtension =\n\t\t\topts.ensureExtension ?? ((p) => (p.endsWith(\".yapl\") ? p : `${p}.yapl`));\n\t}\n\n\tsetBaseDir(dir: string) {\n\t\tthis.baseDir = dir;\n\t}\n\n\tasync renderString(\n\t\ttemplateSource: string,\n\t\tvars: Vars = {},\n\t\tcurrentDir?: string,\n\t): Promise<Prompt> {\n\t\tconst usedFiles = new Set<string>();\n\t\tconst renderedContent = await this.processTemplate(templateSource, {\n\t\t\tvars,\n\t\t\tcurrentDir: currentDir ?? this.baseDir,\n\t\t\tusedFiles,\n\t\t\tdepth: 0,\n\t\t});\n\t\treturn { content: renderedContent, usedFiles: Array.from(usedFiles) };\n\t}\n\n\t// ---------- Core Processing ----------\n\n\tprivate async processTemplate(\n\t\ttemplateSource: string,\n\t\tcontext: RenderContext,\n\t\toptions?: RenderOptionsInternal,\n\t): Promise<string> {\n\t\tif (context.depth > this.maxDepth) {\n\t\t\tthrow new Error(\"Max template depth exceeded (possible recursion).\");\n\t\t}\n\n\t\tlet processedSource = applyTagTrimming(templateSource);\n\t\tprocessedSource = applyGlobalWhitespaceControl(\n\t\t\tprocessedSource,\n\t\t\tthis.whitespaceOptions,\n\t\t);\n\t\t// Strip comments early so they don't interfere with directive parsing\n\t\tprocessedSource = processedSource.replace(COMMENT_REGEX, \"\");\n\n\t\t// Handle template inheritance via {% extends %}\n\t\tif (!options?.noExtends) {\n\t\t\tconst extendsMatch = this.extractDirective(\n\t\t\t\tprocessedSource,\n\t\t\t\tEXTENDS_REGEX,\n\t\t\t);\n\t\t\tif (extendsMatch) {\n\t\t\t\treturn await this.processTemplateInheritance(\n\t\t\t\t\tprocessedSource,\n\t\t\t\t\tcontext,\n\t\t\t\t\textendsMatch[1],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst cleanedSource = this.stripDirectives(processedSource, [\n\t\t\tEXTENDS_REGEX,\n\t\t\tMIXIN_REGEX,\n\t\t]);\n\t\tconst processedIncludes = await this.processDirectives(\n\t\t\tcleanedSource,\n\t\t\tcontext,\n\t\t\tINCLUDE_REGEX,\n\t\t\tthis.processIncludeDirective.bind(this),\n\t\t);\n\t\tconst processedBlocks = await this.processStandaloneBlocks(\n\t\t\tprocessedIncludes,\n\t\t\tcontext,\n\t\t);\n\t\tconst processedIfs = await this.processIfElseStatements(\n\t\t\tprocessedBlocks,\n\t\t\tcontext,\n\t\t);\n\t\tconst cleanedSuper = this.stripDirectives(processedIfs, [SUPER_REGEX]);\n\t\treturn this.processVariableInterpolation(cleanedSuper, context.vars);\n\t}\n\n\tprivate async processTemplateInheritance(\n\t\tchildTemplate: string,\n\t\tcontext: RenderContext,\n\t\tparentTemplatePath: string,\n\t): Promise<string> {\n\t\tconst parentAbsolutePath = this.resolveTemplatePath(\n\t\t\tparentTemplatePath,\n\t\t\tcontext.currentDir,\n\t\t);\n\t\tconst parentContent = await this.loadTemplateFile(parentAbsolutePath);\n\t\tcontext.usedFiles.add(parentAbsolutePath);\n\n\t\tconst parentBlocks = this.extractBlockDefinitions(parentContent);\n\t\tconst mixinBlocks = await this.collectBlocksFromMixins(\n\t\t\tchildTemplate,\n\t\t\tcontext,\n\t\t);\n\t\tconst childBlocks = this.extractBlockDefinitions(childTemplate);\n\n\t\tconst mixinEnhancedBlocks = this.mergeBlocksWithSuper(\n\t\t\tmixinBlocks,\n\t\t\tparentBlocks,\n\t\t);\n\t\tconst finalBlocks = this.mergeBlocksWithSuper(\n\t\t\tchildBlocks,\n\t\t\tmixinEnhancedBlocks,\n\t\t);\n\n\t\treturn await this.applyBlockOverridesToParent(\n\t\t\tparentContent,\n\t\t\tfinalBlocks,\n\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\tcontext.currentDir,\n\t\t);\n\t}\n\n\t// ---------- Directive Processing ----------\n\n\tprivate extractDirective(\n\t\tcontent: string,\n\t\tregex: RegExp,\n\t): RegExpMatchArray | null {\n\t\treturn content.match(regex);\n\t}\n\n\tprivate stripDirectives(content: string, regexes: RegExp[]): string {\n\t\treturn regexes.reduce(\n\t\t\t(result, regex) => result.replace(regex, \"\"),\n\t\t\tcontent,\n\t\t);\n\t}\n\n\tprivate async processDirectives<_T>(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t\tregex: RegExp,\n\t\tprocessor: (\n\t\t\tmatch: RegExpMatchArray,\n\t\t\tcontext: RenderContext,\n\t\t) => Promise<string>,\n\t): Promise<string> {\n\t\treturn await this.replaceAsync(content, regex, async (...match) => {\n\t\t\treturn await processor(match as unknown as RegExpMatchArray, context);\n\t\t});\n\t}\n\n\tprivate async processIncludeDirective(\n\t\tmatch: RegExpMatchArray,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tconst [, templatePath, withClause] = match;\n\t\tconst absolutePath = this.resolveTemplatePath(\n\t\t\ttemplatePath,\n\t\t\tcontext.currentDir,\n\t\t);\n\t\tconst includeContent = await this.loadTemplateFile(absolutePath);\n\t\tcontext.usedFiles.add(absolutePath);\n\n\t\tconst localVars = withClause\n\t\t\t? parseWithObject(withClause, context.vars)\n\t\t\t: {};\n\t\tconst mergedVars = { ...context.vars, ...localVars };\n\n\t\treturn await this.processTemplate(includeContent, {\n\t\t\tvars: mergedVars,\n\t\t\tcurrentDir: this.dirname(absolutePath),\n\t\t\tusedFiles: context.usedFiles,\n\t\t\tdepth: context.depth + 1,\n\t\t});\n\t}\n\n\t// ---------- Block Processing ----------\n\n\tprivate async processStandaloneBlocks(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\treturn await this.replaceAsync(\n\t\t\tcontent,\n\t\t\tBLOCK_REGEX,\n\t\t\tasync (_fullMatch, _blockName, blockContent) => {\n\t\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t\t? dedentText(blockContent)\n\t\t\t\t\t: blockContent;\n\t\t\t\tconst renderedContent = await this.processTemplate(\n\t\t\t\t\tprocessedContent,\n\t\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t\treturn renderedContent;\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate extractBlockDefinitions(content: string): Record<string, string> {\n\t\tconst blocks: Record<string, string> = {};\n\t\tconst blockMatches = Array.from(content.matchAll(BLOCK_REGEX));\n\t\tfor (const match of blockMatches) {\n\t\t\tconst [, blockName, blockContent] = match;\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(blockContent)\n\t\t\t\t: blockContent;\n\t\t\tblocks[blockName] = processedContent;\n\t\t}\n\t\treturn blocks;\n\t}\n\n\tprivate async collectBlocksFromMixins(\n\t\ttemplateContent: string,\n\t\tcontext: RenderContext,\n\t): Promise<Record<string, string>> {\n\t\tconst mixinMatches = Array.from(templateContent.matchAll(MIXIN_REGEX));\n\t\tconst collectedBlocks: Record<string, string> = {};\n\t\tif (mixinMatches.length === 0) return collectedBlocks;\n\n\t\tfor (const mixinMatch of mixinMatches) {\n\t\t\tconst mixinPaths = normalizeList(mixinMatch[1]);\n\t\t\tfor (const mixinPath of mixinPaths) {\n\t\t\t\tconst absolutePath = this.resolveTemplatePath(\n\t\t\t\t\tmixinPath,\n\t\t\t\t\tcontext.currentDir,\n\t\t\t\t);\n\t\t\t\tconst mixinContent = await this.loadTemplateFile(absolutePath);\n\t\t\t\tcontext.usedFiles.add(absolutePath);\n\t\t\t\tconst mixinBlocks = this.extractBlockDefinitions(mixinContent);\n\t\t\t\tthis.mergeBlocksInto(collectedBlocks, mixinBlocks);\n\t\t\t}\n\t\t}\n\t\treturn collectedBlocks;\n\t}\n\n\tprivate mergeBlocksInto(\n\t\ttargetBlocks: Record<string, string>,\n\t\tsourceBlocks: Record<string, string>,\n\t): void {\n\t\tfor (const [blockName, blockContent] of Object.entries(sourceBlocks)) {\n\t\t\ttargetBlocks[blockName] = blockContent;\n\t\t}\n\t}\n\n\tprivate mergeBlocksWithSuper(\n\t\tincomingBlocks: Record<string, string>,\n\t\tbaseBlocks: Record<string, string>,\n\t): Record<string, string> {\n\t\tconst mergedBlocks: Record<string, string> = { ...baseBlocks };\n\t\tfor (const [blockName, blockContent] of Object.entries(incomingBlocks)) {\n\t\t\tconst baseContent = baseBlocks[blockName] ?? \"\";\n\t\t\tmergedBlocks[blockName] = blockContent.replace(SUPER_REGEX, baseContent);\n\t\t}\n\t\treturn mergedBlocks;\n\t}\n\n\t// ---------- If-Else Processing ----------\n\n\tprivate async processIfElseStatements(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\treturn await this.processNestedIfStatements(content, context);\n\t}\n\n\tprivate async processNestedIfStatements(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tlet result = content;\n\t\tconst maxIterations = 50;\n\t\tlet iteration = 0;\n\t\twhile (iteration < maxIterations) {\n\t\t\tconst newResult = await this.processSingleIfStatement(result, context);\n\t\t\tif (newResult === result) break;\n\t\t\tresult = newResult;\n\t\t\titeration++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async processSingleIfStatement(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tconst ifMatch = content.match(/\\{%-?\\s*if\\s+([^%]+?)\\s*-?%\\}/);\n\t\tif (!ifMatch) return content;\n\t\tconst ifStart = ifMatch.index ?? 0;\n\t\tconst condition = ifMatch[1];\n\t\tconst { endifIndex, ifContent, elseContent } = this.findMatchingEndif(\n\t\t\tcontent,\n\t\t\tifStart,\n\t\t);\n\t\tif (endifIndex === -1) return content;\n\t\tconst conditionResult = evaluateCondition(condition, context.vars);\n\t\tlet replacement: string;\n\t\tif (conditionResult) {\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(ifContent)\n\t\t\t\t: ifContent;\n\t\t\treplacement = await this.processTemplate(\n\t\t\t\tprocessedContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t} else if (elseContent !== null) {\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(elseContent)\n\t\t\t\t: elseContent;\n\t\t\treplacement = await this.processTemplate(\n\t\t\t\tprocessedContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t} else {\n\t\t\treplacement = \"\";\n\t\t}\n\t\tconst endifEnd = content.indexOf(\"%}\", endifIndex) + 2;\n\t\tconst fullIfStatement = content.slice(ifStart, endifEnd);\n\t\treturn content.replace(fullIfStatement, replacement);\n\t}\n\n\tprivate findMatchingEndif(\n\t\tcontent: string,\n\t\tifStart: number,\n\t): {\n\t\tendifIndex: number;\n\t\telseIndex: number | null;\n\t\tifContent: string;\n\t\telseContent: string | null;\n\t} {\n\t\tlet depth = 0;\n\t\tlet elseIndex: number | null = null;\n\t\tlet elseTagLength = 0;\n\t\tlet pos = content.indexOf(\"%}\", ifStart) + 2;\n\t\twhile (pos < content.length) {\n\t\t\tconst nextTagMatch = content.slice(pos).match(/\\{%-?\\s*(if|else|endif)/);\n\t\t\tif (!nextTagMatch) break;\n\t\t\tconst tagStart = pos + (nextTagMatch.index ?? 0);\n\t\t\tconst tagType = nextTagMatch[1];\n\t\t\tif (tagType === \"if\") {\n\t\t\t\tdepth++;\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t} else if (tagType === \"else\" && depth === 0 && elseIndex === null) {\n\t\t\t\telseIndex = tagStart;\n\t\t\t\tconst tagEnd = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t\telseTagLength = tagEnd - tagStart;\n\t\t\t\tpos = tagEnd;\n\t\t\t} else if (tagType === \"endif\") {\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\tconst ifTagEnd = content.indexOf(\"%}\", ifStart) + 2;\n\t\t\t\t\tconst ifContent = content.slice(ifTagEnd, elseIndex || tagStart);\n\t\t\t\t\tconst elseContent = elseIndex\n\t\t\t\t\t\t? content.slice(elseIndex + elseTagLength, tagStart)\n\t\t\t\t\t\t: null;\n\t\t\t\t\treturn { endifIndex: tagStart, elseIndex, ifContent, elseContent };\n\t\t\t\t}\n\t\t\t\tdepth--;\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t} else {\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tendifIndex: -1,\n\t\t\telseIndex: null,\n\t\t\tifContent: \"\",\n\t\t\telseContent: null,\n\t\t};\n\t}\n\n\t// ---------- Variable Processing ----------\n\n\tprivate processVariableInterpolation(\n\t\ttemplateContent: string,\n\t\tvars: Vars,\n\t): string {\n\t\treturn templateContent.replace(\n\t\t\tVAR_REGEX,\n\t\t\t(_, variablePath, defaultValue1, defaultValue2) => {\n\t\t\t\tconst variableValue = getPath(vars, variablePath);\n\t\t\t\tconst defaultValue = defaultValue1 ?? defaultValue2;\n\t\t\t\tif (variableValue === undefined || variableValue === null) {\n\t\t\t\t\treturn defaultValue ?? \"\";\n\t\t\t\t}\n\t\t\t\treturn String(variableValue);\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate async applyBlockOverridesToParent(\n\t\tparentContent: string,\n\t\tblockOverrides: Record<string, string>,\n\t\tcontext: RenderContext,\n\t\tchildDir: string,\n\t): Promise<string> {\n\t\tlet processedContent = parentContent;\n\t\tconst parentBlockMatches = Array.from(parentContent.matchAll(BLOCK_REGEX));\n\t\tconst processedBlockNames = new Set<string>();\n\t\tfor (const blockMatch of parentBlockMatches) {\n\t\t\tconst [fullMatch, blockName, parentBlockContent] =\n\t\t\t\tblockMatch as unknown as [string, string, string];\n\t\t\tprocessedBlockNames.add(blockName);\n\t\t\tconst renderedParentContent = await this.processTemplate(\n\t\t\t\tparentBlockContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t\tlet blockReplacement: string;\n\t\t\tif (blockOverrides[blockName] !== undefined) {\n\t\t\t\tconst overrideWithSuper = blockOverrides[blockName].replace(\n\t\t\t\t\tSUPER_REGEX,\n\t\t\t\t\trenderedParentContent,\n\t\t\t\t);\n\t\t\t\tblockReplacement = await this.processTemplate(\n\t\t\t\t\toverrideWithSuper,\n\t\t\t\t\t{\n\t\t\t\t\t\tvars: context.vars,\n\t\t\t\t\t\tcurrentDir: childDir,\n\t\t\t\t\t\tusedFiles: context.usedFiles,\n\t\t\t\t\t\tdepth: context.depth + 1,\n\t\t\t\t\t},\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tblockReplacement = renderedParentContent;\n\t\t\t}\n\t\t\tprocessedContent = processedContent.replace(fullMatch, blockReplacement);\n\t\t}\n\n\t\tprocessedContent = await this.processTemplate(processedContent, context, {\n\t\t\tnoExtends: true,\n\t\t});\n\n\t\tconst childOnlyBlocks: string[] = [];\n\t\tfor (const [blockName, blockContent] of Object.entries(blockOverrides)) {\n\t\t\tif (!processedBlockNames.has(blockName)) {\n\t\t\t\tconst renderedChildBlock = await this.processTemplate(\n\t\t\t\t\tblockContent,\n\t\t\t\t\t{\n\t\t\t\t\t\tvars: context.vars,\n\t\t\t\t\t\tcurrentDir: childDir,\n\t\t\t\t\t\tusedFiles: context.usedFiles,\n\t\t\t\t\t\tdepth: context.depth + 1,\n\t\t\t\t\t},\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t\tchildOnlyBlocks.push(renderedChildBlock);\n\t\t\t}\n\t\t}\n\t\tif (childOnlyBlocks.length > 0) {\n\t\t\tprocessedContent += `\\n${childOnlyBlocks.join(\"\\n\")}`;\n\t\t}\n\t\treturn processedContent;\n\t}\n\n\t// ---------- Loader/Resolver helpers ----------\n\n\tprivate resolveTemplatePath(templateRef: string, fromDir: string): string {\n\t\tif (!this._resolvePath) {\n\t\t\tthrow new Error(\n\t\t\t\t\"No resolvePath provided. File-based operations are not available in this environment.\",\n\t\t\t);\n\t\t}\n\t\treturn this._resolvePath(\n\t\t\tthis._ensureExtension(templateRef),\n\t\t\tfromDir,\n\t\t\tthis._ensureExtension,\n\t\t);\n\t}\n\n\tprivate async loadTemplateFile(absolutePath: string): Promise<string> {\n\t\tif (!this._loadFile) {\n\t\t\tthrow new Error(\n\t\t\t\t\"No loadFile provided. File-based operations are not available in this environment.\",\n\t\t\t);\n\t\t}\n\t\treturn await this._loadFile(absolutePath);\n\t}\n\n\tprivate dirname(p: string): string {\n\t\tconst idx = p.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n\t\treturn idx >= 0 ? p.slice(0, idx) : \"\";\n\t}\n\n\tprivate async replaceAsync(\n\t\tcontent: string,\n\t\tregex: RegExp,\n\t\treplacer: (...match: string[]) => Promise<string>,\n\t): Promise<string> {\n\t\tconst replacementPromises: Promise<string | string[]>[] = [];\n\t\tlet lastIndex = 0;\n\t\tfor (const match of content.matchAll(regex)) {\n\t\t\tconst matchIndex = match.index ?? 0;\n\t\t\treplacementPromises.push(\n\t\t\t\tPromise.resolve(content.slice(lastIndex, matchIndex)),\n\t\t\t);\n\t\t\treplacementPromises.push(replacer(...(match as unknown as string[])));\n\t\t\tlastIndex = matchIndex + match[0].length;\n\t\t}\n\t\treplacementPromises.push(Promise.resolve(content.slice(lastIndex)));\n\t\tconst resolvedParts = await Promise.all(replacementPromises);\n\t\treturn resolvedParts.join(\"\");\n\t}\n}\n","// Browser-compatible path utilities\nfunction resolvePath(basePath: string): string {\n\t// Simple browser path resolution - just normalize slashes\n\treturn basePath.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n}\n\nfunction dirname(filePath: string): string {\n\tconst parts = filePath.split(\"/\");\n\tparts.pop(); // Remove the filename\n\treturn parts.join(\"/\") || \"/\";\n}\n\nexport { default as protectYaplPlugin } from \"./markdown/protectYaplPlugin\";\nexport type {\n\tVars,\n\tWhitespaceOptions,\n\tPrompt,\n\tRendererOptions,\n} from \"./renderer\";\nimport { YAPLRenderer } from \"./renderer\";\nimport type { Prompt, WhitespaceOptions } from \"./renderer\";\n\nexport interface YAPLOptions {\n\tbaseDir: string;\n\tcache?: boolean; // unused in browser wrapper\n\tstrictPaths?: boolean; // unused in browser wrapper\n\tmaxDepth?: number;\n\twhitespace?: WhitespaceOptions;\n\t// Browser-specific options\n\tresolvePath?: (\n\t\ttemplateRef: string,\n\t\tfromDir: string,\n\t\tensureExt: (p: string) => string,\n\t) => string;\n\tloadFile?: (absolutePath: string) => Promise<string>;\n\tensureExtension?: (p: string) => string;\n}\n\nexport class YAPL {\n\tprotected baseDir: string;\n\tprotected renderer: YAPLRenderer;\n\n\tconstructor(opts: YAPLOptions) {\n\t\tthis.baseDir = resolvePath(opts.baseDir);\n\t\tthis.renderer = new YAPLRenderer({\n\t\t\tbaseDir: this.baseDir,\n\t\t\tmaxDepth: opts.maxDepth,\n\t\t\twhitespace: opts.whitespace,\n\t\t\tresolvePath: opts.resolvePath,\n\t\t\tloadFile: opts.loadFile,\n\t\t\tensureExtension: opts.ensureExtension,\n\t\t});\n\t}\n\n\tsetBaseDir(dir: string) {\n\t\tthis.baseDir = resolvePath(dir);\n\t\tthis.renderer.setBaseDir(this.baseDir);\n\t}\n\n\tprivate dirname(filePath: string): string {\n\t\treturn dirname(filePath);\n\t}\n\n\tasync renderString(\n\t\ttemplateSource: string,\n\t\tvars: Record<string, unknown> = {},\n\t\tcurrentDir?: string,\n\t) {\n\t\treturn await this.renderer.renderString(\n\t\t\ttemplateSource,\n\t\t\tvars,\n\t\t\tcurrentDir ? resolvePath(currentDir) : this.baseDir,\n\t\t);\n\t}\n\n\tasync render(\n\t\ttemplatePath: string,\n\t\tvars: Record<string, unknown> = {},\n\t): Promise<Prompt> {\n\t\t// Use the renderer's template loading if loadFile is provided\n\t\tif (!this.renderer.loadFile) {\n\t\t\tthrow new Error(\n\t\t\t\t\"File loading is not available. Provide a loadFile function in YAPLOptions or use renderString for browser usage.\",\n\t\t\t);\n\t\t}\n\n\t\t// Load the template file and render it\n\t\tconst absolutePath = this.renderer.resolvePath\n\t\t\t? this.renderer.resolvePath(\n\t\t\t\t\ttemplatePath,\n\t\t\t\t\tthis.baseDir,\n\t\t\t\t\tthis.renderer.ensureExtension,\n\t\t\t\t)\n\t\t\t: templatePath;\n\n\t\tconst templateContent = await this.renderer.loadFile(absolutePath);\n\t\t// Use the directory of the template file as the current directory\n\t\tconst templateDir = this.dirname(absolutePath);\n\t\treturn await this.renderString(templateContent, vars, templateDir);\n\t}\n}\n"],"names":["protectYaplPlugin","md","origFence","origCodeBlock","origCodeInline","hasYaplDelimiters","s","looksLikeYapl","info","content","tokens","idx","options","env","self","token","rendered","EXTENDS_REGEX","MIXIN_REGEX","INCLUDE_REGEX","BLOCK_REGEX","VAR_REGEX","SUPER_REGEX","COMMENT_REGEX","getPath","obj","dotted","acc","key","evaluateCondition","condition","vars","trimmed","andMatch","leftCondition","rightCondition","orMatch","isDefinedMatch","varPath","notModifier","value","isDefined","isEmptyMatch","isEmpty","comparisonMatch","leftExpr","operator","rightExpr","leftValue","parseValue","rightValue","expr","normalizeList","listLiteral","parseWithObject","literal","parentVars","inner","parts","cur","inStr","esc","ch","p","m","raw","out","k","v","dedentText","text","lines","nonEmptyLines","line","indentLengths","match","minIndent","applyTagTrimming","source","result","applyGlobalWhitespaceControl","YAPLRenderer","opts","dir","templateSource","currentDir","usedFiles","context","processedSource","extendsMatch","cleanedSource","processedIncludes","processedBlocks","processedIfs","cleanedSuper","childTemplate","parentTemplatePath","parentAbsolutePath","parentContent","parentBlocks","mixinBlocks","childBlocks","mixinEnhancedBlocks","finalBlocks","regex","regexes","processor","templatePath","withClause","absolutePath","includeContent","localVars","mergedVars","_fullMatch","_blockName","blockContent","processedContent","blocks","blockMatches","blockName","templateContent","mixinMatches","collectedBlocks","mixinMatch","mixinPaths","mixinPath","mixinContent","targetBlocks","sourceBlocks","incomingBlocks","baseBlocks","mergedBlocks","baseContent","maxIterations","iteration","newResult","ifMatch","ifStart","endifIndex","ifContent","elseContent","conditionResult","replacement","endifEnd","fullIfStatement","depth","elseIndex","elseTagLength","pos","nextTagMatch","tagStart","tagType","tagEnd","ifTagEnd","_","variablePath","defaultValue1","defaultValue2","variableValue","defaultValue","blockOverrides","childDir","parentBlockMatches","processedBlockNames","blockMatch","fullMatch","parentBlockContent","renderedParentContent","blockReplacement","overrideWithSuper","childOnlyBlocks","renderedChildBlock","templateRef","fromDir","replacer","replacementPromises","lastIndex","matchIndex","resolvePath","basePath","dirname","filePath","YAPL","templateDir"],"mappings":"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"}