{"version":3,"file":"index.mjs","sources":["../src/markdown/protectYaplPlugin.ts","../src/constants/regex.ts","../src/utils/getPath.ts","../src/utils/evaluateCondition.ts","../src/utils/normalizeList.ts","../src/utils/parseWithObject.ts","../src/renderer.ts","../src/index.ts"],"sourcesContent":["/**\n * Markdown-it plugin to protect YAPL-like syntax from Vue template compilation.\n *\n * It wraps code fences, indented code blocks, and inline code that contain\n * YAPL/Jinja-like delimiters ({{ ... }} or {% ... %}), or that are tagged\n * with a language info string including \"yapl\", in a Vue v-pre container.\n *\n * This prevents Vue (VitePress/VuePress) from trying to parse the contents\n * as JavaScript template expressions.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n// biome-ignore lint/suspicious/noExplicitAny: markdown-it types are not available\nexport function protectYaplPlugin(md: any) {\n\tconst origFence = md.renderer.rules.fence;\n\tconst origCodeBlock = md.renderer.rules.code_block;\n\tconst origCodeInline = md.renderer.rules.code_inline;\n\n\tconst hasYaplDelimiters = (s: string) =>\n\t\ts.includes(\"{{\") || s.includes(\"{%\") || s.includes(\"{#\");\n\tconst looksLikeYapl = (info: string, content: string) =>\n\t\tinfo?.toLowerCase().includes(\"yapl\") || hasYaplDelimiters(content);\n\n\t// Fenced code blocks ```\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.fence = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst info = (token.info || \"\").trim();\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origFence\n\t\t\t? origFence(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn looksLikeYapl(info, content)\n\t\t\t? `<div v-pre>\\n${rendered}\\n</div>\\n`\n\t\t\t: rendered;\n\t};\n\n\t// Indented code blocks (no language info)\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.code_block = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origCodeBlock\n\t\t\t? origCodeBlock(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn hasYaplDelimiters(content)\n\t\t\t? `<div v-pre>\\n${rendered}\\n</div>\\n`\n\t\t\t: rendered;\n\t};\n\n\t// Inline code `...`\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tmd.renderer.rules.code_inline = (\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\ttokens: any[],\n\t\tidx: number,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\toptions: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tenv: any,\n\t\t// biome-ignore lint/suspicious/noExplicitAny: markdown-it renderer signature\n\t\tself: any,\n\t) => {\n\t\tconst token = tokens[idx];\n\t\tconst content = token.content || \"\";\n\n\t\tconst rendered = origCodeInline\n\t\t\t? origCodeInline(tokens, idx, options, env, self)\n\t\t\t: self.renderToken(tokens, idx, options);\n\n\t\treturn hasYaplDelimiters(content)\n\t\t\t? `<span v-pre>${rendered}</span>`\n\t\t\t: rendered;\n\t};\n}\n\nexport default protectYaplPlugin;\n","export const EXTENDS_REGEX = /\\{%-?\\s*extends\\s+\"([^\"]+)\"\\s*-?%\\}/;\nexport const MIXIN_REGEX =\n\t/\\{%-?\\s*mixin\\s+((?:\"[^\"]+\"\\s*,\\s*)*\"[^\"]+\")\\s*-?%\\}/g;\nexport const INCLUDE_REGEX =\n\t/\\{%-?\\s*include\\s+\"([^\"]+)\"(?:\\s+with\\s+(\\{[\\s\\S]*?\\}))?\\s*-?%\\}/g;\nexport const BLOCK_REGEX =\n\t/\\{%-?\\s*block\\s+([a-zA-Z0-9_:-]+)\\s*-?%\\}([\\s\\S]*?)\\{%-?\\s*endblock\\s*-?%\\}/g;\nexport const VAR_REGEX =\n\t/\\{\\{-?\\s*([a-zA-Z0-9_.]+)(?:\\s*\\|\\s*default\\((?:\"([^\"]*)\"|'([^']*)')\\))?\\s*-?\\}\\}/g;\nexport const SUPER_REGEX = /\\{\\{-?\\s*super\\(\\s*\\)\\s*-?\\}\\}/g;\n\n// Comments\nexport const COMMENT_REGEX = /\\{#-?[\\s\\S]*?-#\\}|\\{#[\\s\\S]*?#\\}/g;\n\n// If-else control structures\nexport const IF_REGEX =\n\t/\\{%-?\\s*if\\s+([^%]+?)\\s*-?%\\}([\\s\\S]*?)(?:\\{%-?\\s*else\\s*-?%\\}([\\s\\S]*?))?\\{%-?\\s*endif\\s*-?%\\}/g;\n","import type { Vars } from \"..\";\n\nexport default function getPath(obj: Vars, dotted: string): unknown {\n\treturn dotted.split(\".\").reduce<unknown>((acc, key) => {\n\t\tif (\n\t\t\tacc &&\n\t\t\ttypeof acc === \"object\" &&\n\t\t\tkey in (acc as Record<string, unknown>)\n\t\t)\n\t\t\treturn (acc as Record<string, unknown>)[key];\n\t\treturn undefined;\n\t}, obj);\n}\n","import type { Vars } from \"..\";\nimport getPath from \"./getPath\";\n\n/**\n * Evaluates a simple condition expression for if statements.\n * Supports basic comparisons and existence checks.\n *\n * Supported operators:\n * - == (equals)\n * - != (not equals)\n * - is defined (variable exists and is not null/undefined)\n * - is not defined (variable is null/undefined)\n * - is empty (variable is null/undefined/empty string/empty array)\n * - is not empty (variable has a value)\n * - and (logical AND)\n * - or (logical OR)\n *\n * Examples:\n * - user.name == \"John\"\n * - count != 0\n * - user.email is defined\n * - items is not empty\n * - status == \"active\"\n * - user.name is defined and user.name != \"\"\n */\nexport default function evaluateCondition(\n\tcondition: string,\n\tvars: Vars,\n): boolean {\n\tconst trimmed = condition.trim();\n\n\t// Handle logical operators (and, or)\n\tconst andMatch = trimmed.match(/^(.+?)\\s+and\\s+(.+)$/);\n\tif (andMatch) {\n\t\tconst [, leftCondition, rightCondition] = andMatch;\n\t\treturn (\n\t\t\tevaluateCondition(leftCondition.trim(), vars) &&\n\t\t\tevaluateCondition(rightCondition.trim(), vars)\n\t\t);\n\t}\n\n\tconst orMatch = trimmed.match(/^(.+?)\\s+or\\s+(.+)$/);\n\tif (orMatch) {\n\t\tconst [, leftCondition, rightCondition] = orMatch;\n\t\treturn (\n\t\t\tevaluateCondition(leftCondition.trim(), vars) ||\n\t\t\tevaluateCondition(rightCondition.trim(), vars)\n\t\t);\n\t}\n\n\t// Handle \"is defined\" / \"is not defined\"\n\tconst isDefinedMatch = trimmed.match(/^(.+?)\\s+is\\s+(not\\s+)?defined$/);\n\tif (isDefinedMatch) {\n\t\tconst [, varPath, notModifier] = isDefinedMatch;\n\t\tconst value = getPath(vars, varPath.trim());\n\t\tconst isDefined = value !== undefined && value !== null;\n\t\treturn notModifier ? !isDefined : isDefined;\n\t}\n\n\t// Handle \"is empty\" / \"is not empty\"\n\tconst isEmptyMatch = trimmed.match(/^(.+?)\\s+is\\s+(not\\s+)?empty$/);\n\tif (isEmptyMatch) {\n\t\tconst [, varPath, notModifier] = isEmptyMatch;\n\t\tconst value = getPath(vars, varPath.trim());\n\t\tconst isEmpty =\n\t\t\tvalue === undefined ||\n\t\t\tvalue === null ||\n\t\t\tvalue === \"\" ||\n\t\t\t(Array.isArray(value) && value.length === 0) ||\n\t\t\t(typeof value === \"object\" && Object.keys(value).length === 0);\n\t\treturn notModifier ? !isEmpty : isEmpty;\n\t}\n\n\t// Handle equality comparisons (== and !=)\n\tconst comparisonMatch = trimmed.match(/^(.+?)\\s*(==|!=)\\s*(.+)$/);\n\tif (comparisonMatch) {\n\t\tconst [, leftExpr, operator, rightExpr] = comparisonMatch;\n\t\tconst leftValue = parseValue(leftExpr.trim(), vars);\n\t\tconst rightValue = parseValue(rightExpr.trim(), vars);\n\n\t\tif (operator === \"==\") {\n\t\t\treturn leftValue === rightValue;\n\t\t}\n\t\tif (operator === \"!=\") {\n\t\t\treturn leftValue !== rightValue;\n\t\t}\n\t}\n\n\t// Handle simple truthiness check (just a variable name)\n\tconst simpleVarMatch = trimmed.match(/^[a-zA-Z0-9_.]+$/);\n\tif (simpleVarMatch) {\n\t\tconst value = getPath(vars, trimmed);\n\t\treturn Boolean(value);\n\t}\n\n\t// If we can't parse the condition, default to false for safety\n\treturn false;\n}\n\n/**\n * Parse a value expression - could be a variable reference, string literal, number, or boolean\n */\nfunction parseValue(expr: string, vars: Vars): unknown {\n\tconst trimmed = expr.trim();\n\n\t// String literal (quoted)\n\tif (\n\t\t(trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\n\t\t(trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\n\t) {\n\t\treturn trimmed.slice(1, -1);\n\t}\n\n\t// Number literal\n\tif (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n\t\treturn Number(trimmed);\n\t}\n\n\t// Boolean literal\n\tif (trimmed === \"true\") return true;\n\tif (trimmed === \"false\") return false;\n\tif (trimmed === \"null\") return null;\n\n\t// Variable reference\n\treturn getPath(vars, trimmed);\n}\n","export default function normalizeList(listLiteral: string): string[] {\n\t// takes `\"a\", \"b\", \"c\"` or `\"a\"` and returns [\"a\",\"b\",\"c\"]\n\tconst items = listLiteral.match(/\"([^\"]+)\"/g) || [];\n\treturn items.map((s) => s.slice(1, -1));\n}\n","import type { Vars } from \"..\";\nimport getPath from \"./getPath\";\n\nexport default function parseWithObject(\n\tliteral: string,\n\tparentVars: Vars,\n): Vars {\n\t// literal is a JSON-like object with support for bare identifiers as variable references.\n\t// Example: {\"lang\":\"en\",\"name\": user.name, \"flag\": true, \"n\": 3}\n\t// Strategy: tokenize values; if unquoted identifier -> look up in parentVars.\n\ttype Token = { k: string; v: string };\n\tconst tokens: Token[] = [];\n\t// naive parse that handles strings, numbers, booleans, null, identifiers\n\tconst inner = literal.trim().replace(/^\\{|\\}$/g, \"\");\n\tif (!inner.trim()) return {};\n\t// split on commas not inside quotes\n\tconst parts: string[] = [];\n\tlet cur = \"\";\n\tlet inStr: string | null = null;\n\tlet esc = false;\n\tfor (const ch of inner) {\n\t\tif (inStr) {\n\t\t\tif (esc) {\n\t\t\t\tcur += ch;\n\t\t\t\tesc = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === \"\\\\\") {\n\t\t\t\tcur += ch;\n\t\t\t\tesc = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch === inStr) {\n\t\t\t\tinStr = null;\n\t\t\t\tcur += ch;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcur += ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\tinStr = ch;\n\t\t\tcur += ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === \",\") {\n\t\t\tparts.push(cur.trim());\n\t\t\tcur = \"\";\n\t\t\tcontinue;\n\t\t}\n\t\tcur += ch;\n\t}\n\tif (cur.trim()) parts.push(cur.trim());\n\tfor (const p of parts) {\n\t\tconst m = p.match(/^\\s*(\"?)([A-Za-z0-9_.-]+)\\1\\s*:\\s*(.+)\\s*$/);\n\t\tif (!m) continue;\n\t\tconst key = m[2];\n\t\tconst raw = m[3];\n\t\ttokens.push({ k: key, v: raw });\n\t}\n\tconst out: Vars = {};\n\tfor (const { k, v } of tokens) {\n\t\tconst trimmed = v.trim();\n\t\t// string?\n\t\tif (\n\t\t\t(trimmed.startsWith('\"') && trimmed.endsWith('\"')) ||\n\t\t\t(trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\"))\n\t\t) {\n\t\t\tout[k] = trimmed.slice(1, -1);\n\t\t\tcontinue;\n\t\t}\n\t\t// number?\n\t\tif (/^-?\\d+(\\.\\d+)?$/.test(trimmed)) {\n\t\t\tout[k] = Number(trimmed);\n\t\t\tcontinue;\n\t\t}\n\t\t// boolean/null?\n\t\tif (trimmed === \"true\") {\n\t\t\tout[k] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif (trimmed === \"false\") {\n\t\t\tout[k] = false;\n\t\t\tcontinue;\n\t\t}\n\t\tif (trimmed === \"null\") {\n\t\t\tout[k] = null;\n\t\t\tcontinue;\n\t\t}\n\t\t// identifier -> lookup in parent vars\n\t\tout[k] = getPath(parentVars, trimmed);\n\t}\n\treturn out;\n}\n","export type Vars = Record<string, unknown>;\nimport {\n\tBLOCK_REGEX,\n\tCOMMENT_REGEX,\n\tEXTENDS_REGEX,\n\tINCLUDE_REGEX,\n\tMIXIN_REGEX,\n\tSUPER_REGEX,\n\tVAR_REGEX,\n} from \"./constants/regex\";\nimport evaluateCondition from \"./utils/evaluateCondition\";\nimport getPath from \"./utils/getPath\";\nimport normalizeList from \"./utils/normalizeList\";\nimport parseWithObject from \"./utils/parseWithObject\";\n\nexport interface WhitespaceOptions {\n\ttrimBlocks?: boolean;\n\tlstripBlocks?: boolean;\n\tdedentBlocks?: boolean;\n}\n\nexport interface RendererOptions {\n\tbaseDir?: string;\n\tstrictPaths?: boolean;\n\tmaxDepth?: number;\n\twhitespace?: WhitespaceOptions;\n\t// Optional hooks to resolve and load templates (for includes/extends/mixins)\n\tresolvePath?: (\n\t\ttemplateRef: string,\n\t\tfromDir: string,\n\t\tensureExt: (p: string) => string,\n\t) => string;\n\tloadFile?: (absolutePath: string) => Promise<string>;\n\tensureExtension?: (p: string) => string;\n}\n\nexport interface Prompt {\n\tcontent: string;\n\tusedFiles: string[];\n}\n\ninterface RenderContext {\n\tvars: Vars;\n\tcurrentDir: string;\n\tusedFiles: Set<string>;\n\tdepth: number;\n}\n\ninterface RenderOptionsInternal {\n\tnoExtends?: boolean;\n}\n\n// ---------- Whitespace Control Helpers ----------\n\nfunction dedentText(text: string): string {\n\tconst lines = text\n\t\t.replace(/^\\n/, \"\")\n\t\t.replace(/\\n\\s*$/, \"\")\n\t\t.split(\"\\n\");\n\tconst nonEmptyLines = lines.filter((line) => line.trim().length > 0);\n\tif (nonEmptyLines.length === 0) return text;\n\tconst indentLengths = nonEmptyLines.map((line) => {\n\t\tconst match = line.match(/^[ \\t]*/);\n\t\treturn match ? match[0].length : 0;\n\t});\n\tconst minIndent = Math.min(...indentLengths);\n\treturn lines.map((line) => line.slice(minIndent)).join(\"\\n\");\n}\n\nfunction applyTagTrimming(source: string): string {\n\tlet result = source;\n\t// Variable tags\n\tresult = result.replace(/[ \\t]*\\{\\{-/g, \"{{\");\n\tresult = result.replace(/-\\}\\}[ \\t]*\\r?\\n?/g, \"}}\");\n\t// Control tags\n\tresult = result.replace(/[ \\t]*\\{%-/g, \"{%\");\n\tresult = result.replace(/-%\\}[ \\t]*\\r?\\n?/g, \"%}\");\n\t// Comment tags\n\tresult = result.replace(/[ \\t]*\\{#-/g, \"{#\");\n\tresult = result.replace(/-#\\}[ \\t]*\\r?\\n?/g, \"#}\");\n\treturn result;\n}\n\nfunction applyGlobalWhitespaceControl(\n\tsource: string,\n\toptions: WhitespaceOptions,\n): string {\n\tlet result = source;\n\tif (options.lstripBlocks) {\n\t\tresult = result.replace(/^[ \\t]+(?=\\{%)/gm, \"\");\n\t}\n\tif (options.trimBlocks) {\n\t\tresult = result.replace(/%\\}[ \\t]*\\r?\\n/g, \"%}\");\n\t}\n\treturn result;\n}\n\nexport class YAPLRenderer {\n\tprivate baseDir: string;\n\tprivate strictPaths: boolean;\n\tprivate maxDepth: number;\n\tprivate whitespaceOptions: WhitespaceOptions;\n\tprivate _resolvePath?: RendererOptions[\"resolvePath\"];\n\tprivate _loadFile?: RendererOptions[\"loadFile\"];\n\tprivate _ensureExtension: (p: string) => string;\n\n\t// Public getters for browser compatibility\n\tget loadFile() {\n\t\treturn this._loadFile;\n\t}\n\tget resolvePath() {\n\t\treturn this._resolvePath;\n\t}\n\tget ensureExtension() {\n\t\treturn this._ensureExtension;\n\t}\n\n\tconstructor(opts: RendererOptions = {}) {\n\t\tthis.baseDir = opts.baseDir ? opts.baseDir : \"\";\n\t\tthis.strictPaths = opts.strictPaths !== false;\n\t\tthis.maxDepth = opts.maxDepth ?? 20;\n\t\tthis.whitespaceOptions = {\n\t\t\ttrimBlocks: opts.whitespace?.trimBlocks ?? true,\n\t\t\tlstripBlocks: opts.whitespace?.lstripBlocks ?? true,\n\t\t\tdedentBlocks: opts.whitespace?.dedentBlocks ?? true,\n\t\t};\n\t\tthis._resolvePath = opts.resolvePath;\n\t\tthis._loadFile = opts.loadFile;\n\t\tthis._ensureExtension =\n\t\t\topts.ensureExtension ?? ((p) => (p.endsWith(\".yapl\") ? p : `${p}.yapl`));\n\t}\n\n\tsetBaseDir(dir: string) {\n\t\tthis.baseDir = dir;\n\t}\n\n\tasync renderString(\n\t\ttemplateSource: string,\n\t\tvars: Vars = {},\n\t\tcurrentDir?: string,\n\t): Promise<Prompt> {\n\t\tconst usedFiles = new Set<string>();\n\t\tconst renderedContent = await this.processTemplate(templateSource, {\n\t\t\tvars,\n\t\t\tcurrentDir: currentDir ?? this.baseDir,\n\t\t\tusedFiles,\n\t\t\tdepth: 0,\n\t\t});\n\t\treturn { content: renderedContent, usedFiles: Array.from(usedFiles) };\n\t}\n\n\t// ---------- Core Processing ----------\n\n\tprivate async processTemplate(\n\t\ttemplateSource: string,\n\t\tcontext: RenderContext,\n\t\toptions?: RenderOptionsInternal,\n\t): Promise<string> {\n\t\tif (context.depth > this.maxDepth) {\n\t\t\tthrow new Error(\"Max template depth exceeded (possible recursion).\");\n\t\t}\n\n\t\tlet processedSource = applyTagTrimming(templateSource);\n\t\tprocessedSource = applyGlobalWhitespaceControl(\n\t\t\tprocessedSource,\n\t\t\tthis.whitespaceOptions,\n\t\t);\n\t\t// Strip comments early so they don't interfere with directive parsing\n\t\tprocessedSource = processedSource.replace(COMMENT_REGEX, \"\");\n\n\t\t// Handle template inheritance via {% extends %}\n\t\tif (!options?.noExtends) {\n\t\t\tconst extendsMatch = this.extractDirective(\n\t\t\t\tprocessedSource,\n\t\t\t\tEXTENDS_REGEX,\n\t\t\t);\n\t\t\tif (extendsMatch) {\n\t\t\t\treturn await this.processTemplateInheritance(\n\t\t\t\t\tprocessedSource,\n\t\t\t\t\tcontext,\n\t\t\t\t\textendsMatch[1],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst cleanedSource = this.stripDirectives(processedSource, [\n\t\t\tEXTENDS_REGEX,\n\t\t\tMIXIN_REGEX,\n\t\t]);\n\t\tconst processedIncludes = await this.processDirectives(\n\t\t\tcleanedSource,\n\t\t\tcontext,\n\t\t\tINCLUDE_REGEX,\n\t\t\tthis.processIncludeDirective.bind(this),\n\t\t);\n\t\tconst processedBlocks = await this.processStandaloneBlocks(\n\t\t\tprocessedIncludes,\n\t\t\tcontext,\n\t\t);\n\t\tconst processedIfs = await this.processIfElseStatements(\n\t\t\tprocessedBlocks,\n\t\t\tcontext,\n\t\t);\n\t\tconst cleanedSuper = this.stripDirectives(processedIfs, [SUPER_REGEX]);\n\t\treturn this.processVariableInterpolation(cleanedSuper, context.vars);\n\t}\n\n\tprivate async processTemplateInheritance(\n\t\tchildTemplate: string,\n\t\tcontext: RenderContext,\n\t\tparentTemplatePath: string,\n\t): Promise<string> {\n\t\tconst parentAbsolutePath = this.resolveTemplatePath(\n\t\t\tparentTemplatePath,\n\t\t\tcontext.currentDir,\n\t\t);\n\t\tconst parentContent = await this.loadTemplateFile(parentAbsolutePath);\n\t\tcontext.usedFiles.add(parentAbsolutePath);\n\n\t\tconst parentBlocks = this.extractBlockDefinitions(parentContent);\n\t\tconst mixinBlocks = await this.collectBlocksFromMixins(\n\t\t\tchildTemplate,\n\t\t\tcontext,\n\t\t);\n\t\tconst childBlocks = this.extractBlockDefinitions(childTemplate);\n\n\t\tconst mixinEnhancedBlocks = this.mergeBlocksWithSuper(\n\t\t\tmixinBlocks,\n\t\t\tparentBlocks,\n\t\t);\n\t\tconst finalBlocks = this.mergeBlocksWithSuper(\n\t\t\tchildBlocks,\n\t\t\tmixinEnhancedBlocks,\n\t\t);\n\n\t\treturn await this.applyBlockOverridesToParent(\n\t\t\tparentContent,\n\t\t\tfinalBlocks,\n\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\tcontext.currentDir,\n\t\t);\n\t}\n\n\t// ---------- Directive Processing ----------\n\n\tprivate extractDirective(\n\t\tcontent: string,\n\t\tregex: RegExp,\n\t): RegExpMatchArray | null {\n\t\treturn content.match(regex);\n\t}\n\n\tprivate stripDirectives(content: string, regexes: RegExp[]): string {\n\t\treturn regexes.reduce(\n\t\t\t(result, regex) => result.replace(regex, \"\"),\n\t\t\tcontent,\n\t\t);\n\t}\n\n\tprivate async processDirectives<_T>(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t\tregex: RegExp,\n\t\tprocessor: (\n\t\t\tmatch: RegExpMatchArray,\n\t\t\tcontext: RenderContext,\n\t\t) => Promise<string>,\n\t): Promise<string> {\n\t\treturn await this.replaceAsync(content, regex, async (...match) => {\n\t\t\treturn await processor(match as unknown as RegExpMatchArray, context);\n\t\t});\n\t}\n\n\tprivate async processIncludeDirective(\n\t\tmatch: RegExpMatchArray,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tconst [, templatePath, withClause] = match;\n\t\tconst absolutePath = this.resolveTemplatePath(\n\t\t\ttemplatePath,\n\t\t\tcontext.currentDir,\n\t\t);\n\t\tconst includeContent = await this.loadTemplateFile(absolutePath);\n\t\tcontext.usedFiles.add(absolutePath);\n\n\t\tconst localVars = withClause\n\t\t\t? parseWithObject(withClause, context.vars)\n\t\t\t: {};\n\t\tconst mergedVars = { ...context.vars, ...localVars };\n\n\t\treturn await this.processTemplate(includeContent, {\n\t\t\tvars: mergedVars,\n\t\t\tcurrentDir: this.dirname(absolutePath),\n\t\t\tusedFiles: context.usedFiles,\n\t\t\tdepth: context.depth + 1,\n\t\t});\n\t}\n\n\t// ---------- Block Processing ----------\n\n\tprivate async processStandaloneBlocks(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\treturn await this.replaceAsync(\n\t\t\tcontent,\n\t\t\tBLOCK_REGEX,\n\t\t\tasync (_fullMatch, _blockName, blockContent) => {\n\t\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t\t? dedentText(blockContent)\n\t\t\t\t\t: blockContent;\n\t\t\t\tconst renderedContent = await this.processTemplate(\n\t\t\t\t\tprocessedContent,\n\t\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t\treturn renderedContent;\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate extractBlockDefinitions(content: string): Record<string, string> {\n\t\tconst blocks: Record<string, string> = {};\n\t\tconst blockMatches = Array.from(content.matchAll(BLOCK_REGEX));\n\t\tfor (const match of blockMatches) {\n\t\t\tconst [, blockName, blockContent] = match;\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(blockContent)\n\t\t\t\t: blockContent;\n\t\t\tblocks[blockName] = processedContent;\n\t\t}\n\t\treturn blocks;\n\t}\n\n\tprivate async collectBlocksFromMixins(\n\t\ttemplateContent: string,\n\t\tcontext: RenderContext,\n\t): Promise<Record<string, string>> {\n\t\tconst mixinMatches = Array.from(templateContent.matchAll(MIXIN_REGEX));\n\t\tconst collectedBlocks: Record<string, string> = {};\n\t\tif (mixinMatches.length === 0) return collectedBlocks;\n\n\t\tfor (const mixinMatch of mixinMatches) {\n\t\t\tconst mixinPaths = normalizeList(mixinMatch[1]);\n\t\t\tfor (const mixinPath of mixinPaths) {\n\t\t\t\tconst absolutePath = this.resolveTemplatePath(\n\t\t\t\t\tmixinPath,\n\t\t\t\t\tcontext.currentDir,\n\t\t\t\t);\n\t\t\t\tconst mixinContent = await this.loadTemplateFile(absolutePath);\n\t\t\t\tcontext.usedFiles.add(absolutePath);\n\t\t\t\tconst mixinBlocks = this.extractBlockDefinitions(mixinContent);\n\t\t\t\tthis.mergeBlocksInto(collectedBlocks, mixinBlocks);\n\t\t\t}\n\t\t}\n\t\treturn collectedBlocks;\n\t}\n\n\tprivate mergeBlocksInto(\n\t\ttargetBlocks: Record<string, string>,\n\t\tsourceBlocks: Record<string, string>,\n\t): void {\n\t\tfor (const [blockName, blockContent] of Object.entries(sourceBlocks)) {\n\t\t\ttargetBlocks[blockName] = blockContent;\n\t\t}\n\t}\n\n\tprivate mergeBlocksWithSuper(\n\t\tincomingBlocks: Record<string, string>,\n\t\tbaseBlocks: Record<string, string>,\n\t): Record<string, string> {\n\t\tconst mergedBlocks: Record<string, string> = { ...baseBlocks };\n\t\tfor (const [blockName, blockContent] of Object.entries(incomingBlocks)) {\n\t\t\tconst baseContent = baseBlocks[blockName] ?? \"\";\n\t\t\tmergedBlocks[blockName] = blockContent.replace(SUPER_REGEX, baseContent);\n\t\t}\n\t\treturn mergedBlocks;\n\t}\n\n\t// ---------- If-Else Processing ----------\n\n\tprivate async processIfElseStatements(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\treturn await this.processNestedIfStatements(content, context);\n\t}\n\n\tprivate async processNestedIfStatements(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tlet result = content;\n\t\tconst maxIterations = 50;\n\t\tlet iteration = 0;\n\t\twhile (iteration < maxIterations) {\n\t\t\tconst newResult = await this.processSingleIfStatement(result, context);\n\t\t\tif (newResult === result) break;\n\t\t\tresult = newResult;\n\t\t\titeration++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async processSingleIfStatement(\n\t\tcontent: string,\n\t\tcontext: RenderContext,\n\t): Promise<string> {\n\t\tconst ifMatch = content.match(/\\{%-?\\s*if\\s+([^%]+?)\\s*-?%\\}/);\n\t\tif (!ifMatch) return content;\n\t\tconst ifStart = ifMatch.index ?? 0;\n\t\tconst condition = ifMatch[1];\n\t\tconst { endifIndex, ifContent, elseContent } = this.findMatchingEndif(\n\t\t\tcontent,\n\t\t\tifStart,\n\t\t);\n\t\tif (endifIndex === -1) return content;\n\t\tconst conditionResult = evaluateCondition(condition, context.vars);\n\t\tlet replacement: string;\n\t\tif (conditionResult) {\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(ifContent)\n\t\t\t\t: ifContent;\n\t\t\treplacement = await this.processTemplate(\n\t\t\t\tprocessedContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t} else if (elseContent !== null) {\n\t\t\tconst processedContent = this.whitespaceOptions.dedentBlocks\n\t\t\t\t? dedentText(elseContent)\n\t\t\t\t: elseContent;\n\t\t\treplacement = await this.processTemplate(\n\t\t\t\tprocessedContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t} else {\n\t\t\treplacement = \"\";\n\t\t}\n\t\tconst endifEnd = content.indexOf(\"%}\", endifIndex) + 2;\n\t\tconst fullIfStatement = content.slice(ifStart, endifEnd);\n\t\treturn content.replace(fullIfStatement, replacement);\n\t}\n\n\tprivate findMatchingEndif(\n\t\tcontent: string,\n\t\tifStart: number,\n\t): {\n\t\tendifIndex: number;\n\t\telseIndex: number | null;\n\t\tifContent: string;\n\t\telseContent: string | null;\n\t} {\n\t\tlet depth = 0;\n\t\tlet elseIndex: number | null = null;\n\t\tlet elseTagLength = 0;\n\t\tlet pos = content.indexOf(\"%}\", ifStart) + 2;\n\t\twhile (pos < content.length) {\n\t\t\tconst nextTagMatch = content.slice(pos).match(/\\{%-?\\s*(if|else|endif)/);\n\t\t\tif (!nextTagMatch) break;\n\t\t\tconst tagStart = pos + (nextTagMatch.index ?? 0);\n\t\t\tconst tagType = nextTagMatch[1];\n\t\t\tif (tagType === \"if\") {\n\t\t\t\tdepth++;\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t} else if (tagType === \"else\" && depth === 0 && elseIndex === null) {\n\t\t\t\telseIndex = tagStart;\n\t\t\t\tconst tagEnd = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t\telseTagLength = tagEnd - tagStart;\n\t\t\t\tpos = tagEnd;\n\t\t\t} else if (tagType === \"endif\") {\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\tconst ifTagEnd = content.indexOf(\"%}\", ifStart) + 2;\n\t\t\t\t\tconst ifContent = content.slice(ifTagEnd, elseIndex || tagStart);\n\t\t\t\t\tconst elseContent = elseIndex\n\t\t\t\t\t\t? content.slice(elseIndex + elseTagLength, tagStart)\n\t\t\t\t\t\t: null;\n\t\t\t\t\treturn { endifIndex: tagStart, elseIndex, ifContent, elseContent };\n\t\t\t\t}\n\t\t\t\tdepth--;\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t} else {\n\t\t\t\tpos = content.indexOf(\"%}\", tagStart) + 2;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tendifIndex: -1,\n\t\t\telseIndex: null,\n\t\t\tifContent: \"\",\n\t\t\telseContent: null,\n\t\t};\n\t}\n\n\t// ---------- Variable Processing ----------\n\n\tprivate processVariableInterpolation(\n\t\ttemplateContent: string,\n\t\tvars: Vars,\n\t): string {\n\t\treturn templateContent.replace(\n\t\t\tVAR_REGEX,\n\t\t\t(_, variablePath, defaultValue1, defaultValue2) => {\n\t\t\t\tconst variableValue = getPath(vars, variablePath);\n\t\t\t\tconst defaultValue = defaultValue1 ?? defaultValue2;\n\t\t\t\tif (variableValue === undefined || variableValue === null) {\n\t\t\t\t\treturn defaultValue ?? \"\";\n\t\t\t\t}\n\t\t\t\treturn String(variableValue);\n\t\t\t},\n\t\t);\n\t}\n\n\tprivate async applyBlockOverridesToParent(\n\t\tparentContent: string,\n\t\tblockOverrides: Record<string, string>,\n\t\tcontext: RenderContext,\n\t\tchildDir: string,\n\t): Promise<string> {\n\t\tlet processedContent = parentContent;\n\t\tconst parentBlockMatches = Array.from(parentContent.matchAll(BLOCK_REGEX));\n\t\tconst processedBlockNames = new Set<string>();\n\t\tfor (const blockMatch of parentBlockMatches) {\n\t\t\tconst [fullMatch, blockName, parentBlockContent] =\n\t\t\t\tblockMatch as unknown as [string, string, string];\n\t\t\tprocessedBlockNames.add(blockName);\n\t\t\tconst renderedParentContent = await this.processTemplate(\n\t\t\t\tparentBlockContent,\n\t\t\t\t{ ...context, depth: context.depth + 1 },\n\t\t\t\t{ noExtends: true },\n\t\t\t);\n\t\t\tlet blockReplacement: string;\n\t\t\tif (blockOverrides[blockName] !== undefined) {\n\t\t\t\tconst overrideWithSuper = blockOverrides[blockName].replace(\n\t\t\t\t\tSUPER_REGEX,\n\t\t\t\t\trenderedParentContent,\n\t\t\t\t);\n\t\t\t\tblockReplacement = await this.processTemplate(\n\t\t\t\t\toverrideWithSuper,\n\t\t\t\t\t{\n\t\t\t\t\t\tvars: context.vars,\n\t\t\t\t\t\tcurrentDir: childDir,\n\t\t\t\t\t\tusedFiles: context.usedFiles,\n\t\t\t\t\t\tdepth: context.depth + 1,\n\t\t\t\t\t},\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tblockReplacement = renderedParentContent;\n\t\t\t}\n\t\t\tprocessedContent = processedContent.replace(fullMatch, blockReplacement);\n\t\t}\n\n\t\tprocessedContent = await this.processTemplate(processedContent, context, {\n\t\t\tnoExtends: true,\n\t\t});\n\n\t\tconst childOnlyBlocks: string[] = [];\n\t\tfor (const [blockName, blockContent] of Object.entries(blockOverrides)) {\n\t\t\tif (!processedBlockNames.has(blockName)) {\n\t\t\t\tconst renderedChildBlock = await this.processTemplate(\n\t\t\t\t\tblockContent,\n\t\t\t\t\t{\n\t\t\t\t\t\tvars: context.vars,\n\t\t\t\t\t\tcurrentDir: childDir,\n\t\t\t\t\t\tusedFiles: context.usedFiles,\n\t\t\t\t\t\tdepth: context.depth + 1,\n\t\t\t\t\t},\n\t\t\t\t\t{ noExtends: true },\n\t\t\t\t);\n\t\t\t\tchildOnlyBlocks.push(renderedChildBlock);\n\t\t\t}\n\t\t}\n\t\tif (childOnlyBlocks.length > 0) {\n\t\t\tprocessedContent += `\\n${childOnlyBlocks.join(\"\\n\")}`;\n\t\t}\n\t\treturn processedContent;\n\t}\n\n\t// ---------- Loader/Resolver helpers ----------\n\n\tprivate resolveTemplatePath(templateRef: string, fromDir: string): string {\n\t\tif (!this._resolvePath) {\n\t\t\tthrow new Error(\n\t\t\t\t\"No resolvePath provided. File-based operations are not available in this environment.\",\n\t\t\t);\n\t\t}\n\t\treturn this._resolvePath(\n\t\t\tthis._ensureExtension(templateRef),\n\t\t\tfromDir,\n\t\t\tthis._ensureExtension,\n\t\t);\n\t}\n\n\tprivate async loadTemplateFile(absolutePath: string): Promise<string> {\n\t\tif (!this._loadFile) {\n\t\t\tthrow new Error(\n\t\t\t\t\"No loadFile provided. File-based operations are not available in this environment.\",\n\t\t\t);\n\t\t}\n\t\treturn await this._loadFile(absolutePath);\n\t}\n\n\tprivate dirname(p: string): string {\n\t\tconst idx = p.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n\t\treturn idx >= 0 ? p.slice(0, idx) : \"\";\n\t}\n\n\tprivate async replaceAsync(\n\t\tcontent: string,\n\t\tregex: RegExp,\n\t\treplacer: (...match: string[]) => Promise<string>,\n\t): Promise<string> {\n\t\tconst replacementPromises: Promise<string | string[]>[] = [];\n\t\tlet lastIndex = 0;\n\t\tfor (const match of content.matchAll(regex)) {\n\t\t\tconst matchIndex = match.index ?? 0;\n\t\t\treplacementPromises.push(\n\t\t\t\tPromise.resolve(content.slice(lastIndex, matchIndex)),\n\t\t\t);\n\t\t\treplacementPromises.push(replacer(...(match as unknown as string[])));\n\t\t\tlastIndex = matchIndex + match[0].length;\n\t\t}\n\t\treplacementPromises.push(Promise.resolve(content.slice(lastIndex)));\n\t\tconst resolvedParts = await Promise.all(replacementPromises);\n\t\treturn resolvedParts.join(\"\");\n\t}\n}\n","// Browser-compatible path utilities\nfunction resolvePath(basePath: string): string {\n\t// Simple browser path resolution - just normalize slashes\n\treturn basePath.replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n}\n\nfunction dirname(filePath: string): string {\n\tconst parts = filePath.split(\"/\");\n\tparts.pop(); // Remove the filename\n\treturn parts.join(\"/\") || \"/\";\n}\n\nexport { default as protectYaplPlugin } from \"./markdown/protectYaplPlugin\";\nexport type {\n\tVars,\n\tWhitespaceOptions,\n\tPrompt,\n\tRendererOptions,\n} from \"./renderer\";\nimport { YAPLRenderer } from \"./renderer\";\nimport type { Prompt, WhitespaceOptions } from \"./renderer\";\n\nexport interface YAPLOptions {\n\tbaseDir: string;\n\tcache?: boolean; // unused in browser wrapper\n\tstrictPaths?: boolean; // unused in browser wrapper\n\tmaxDepth?: number;\n\twhitespace?: WhitespaceOptions;\n\t// Browser-specific options\n\tresolvePath?: (\n\t\ttemplateRef: string,\n\t\tfromDir: string,\n\t\tensureExt: (p: string) => string,\n\t) => string;\n\tloadFile?: (absolutePath: string) => Promise<string>;\n\tensureExtension?: (p: string) => string;\n}\n\nexport class YAPL {\n\tprotected baseDir: string;\n\tprotected renderer: YAPLRenderer;\n\n\tconstructor(opts: YAPLOptions) {\n\t\tthis.baseDir = resolvePath(opts.baseDir);\n\t\tthis.renderer = new YAPLRenderer({\n\t\t\tbaseDir: this.baseDir,\n\t\t\tmaxDepth: opts.maxDepth,\n\t\t\twhitespace: opts.whitespace,\n\t\t\tresolvePath: opts.resolvePath,\n\t\t\tloadFile: opts.loadFile,\n\t\t\tensureExtension: opts.ensureExtension,\n\t\t});\n\t}\n\n\tsetBaseDir(dir: string) {\n\t\tthis.baseDir = resolvePath(dir);\n\t\tthis.renderer.setBaseDir(this.baseDir);\n\t}\n\n\tprivate dirname(filePath: string): string {\n\t\treturn dirname(filePath);\n\t}\n\n\tasync renderString(\n\t\ttemplateSource: string,\n\t\tvars: Record<string, unknown> = {},\n\t\tcurrentDir?: string,\n\t) {\n\t\treturn await this.renderer.renderString(\n\t\t\ttemplateSource,\n\t\t\tvars,\n\t\t\tcurrentDir ? resolvePath(currentDir) : this.baseDir,\n\t\t);\n\t}\n\n\tasync render(\n\t\ttemplatePath: string,\n\t\tvars: Record<string, unknown> = {},\n\t): Promise<Prompt> {\n\t\t// Use the renderer's template loading if loadFile is provided\n\t\tif (!this.renderer.loadFile) {\n\t\t\tthrow new Error(\n\t\t\t\t\"File loading is not available. Provide a loadFile function in YAPLOptions or use renderString for browser usage.\",\n\t\t\t);\n\t\t}\n\n\t\t// Load the template file and render it\n\t\tconst absolutePath = this.renderer.resolvePath\n\t\t\t? this.renderer.resolvePath(\n\t\t\t\t\ttemplatePath,\n\t\t\t\t\tthis.baseDir,\n\t\t\t\t\tthis.renderer.ensureExtension,\n\t\t\t\t)\n\t\t\t: templatePath;\n\n\t\tconst templateContent = await this.renderer.loadFile(absolutePath);\n\t\t// Use the directory of the template file as the current directory\n\t\tconst templateDir = this.dirname(absolutePath);\n\t\treturn await this.renderString(templateContent, vars, templateDir);\n\t}\n}\n"],"names":["protectYaplPlugin","md","origFence","origCodeBlock","origCodeInline","hasYaplDelimiters","s","looksLikeYapl","info","content","tokens","idx","options","env","self","token","rendered","EXTENDS_REGEX","MIXIN_REGEX","INCLUDE_REGEX","BLOCK_REGEX","VAR_REGEX","SUPER_REGEX","COMMENT_REGEX","getPath","obj","dotted","acc","key","evaluateCondition","condition","vars","trimmed","andMatch","leftCondition","rightCondition","orMatch","isDefinedMatch","varPath","notModifier","value","isDefined","isEmptyMatch","isEmpty","comparisonMatch","leftExpr","operator","rightExpr","leftValue","parseValue","rightValue","expr","normalizeList","listLiteral","parseWithObject","literal","parentVars","inner","parts","cur","inStr","esc","ch","p","m","raw","out","k","v","dedentText","text","lines","nonEmptyLines","line","indentLengths","match","minIndent","applyTagTrimming","source","result","applyGlobalWhitespaceControl","YAPLRenderer","opts","dir","templateSource","currentDir","usedFiles","context","processedSource","extendsMatch","cleanedSource","processedIncludes","processedBlocks","processedIfs","cleanedSuper","childTemplate","parentTemplatePath","parentAbsolutePath","parentContent","parentBlocks","mixinBlocks","childBlocks","mixinEnhancedBlocks","finalBlocks","regex","regexes","processor","templatePath","withClause","absolutePath","includeContent","localVars","mergedVars","_fullMatch","_blockName","blockContent","processedContent","blocks","blockMatches","blockName","templateContent","mixinMatches","collectedBlocks","mixinMatch","mixinPaths","mixinPath","mixinContent","targetBlocks","sourceBlocks","incomingBlocks","baseBlocks","mergedBlocks","baseContent","maxIterations","iteration","newResult","ifMatch","ifStart","endifIndex","ifContent","elseContent","conditionResult","replacement","endifEnd","fullIfStatement","depth","elseIndex","elseTagLength","pos","nextTagMatch","tagStart","tagType","tagEnd","ifTagEnd","_","variablePath","defaultValue1","defaultValue2","variableValue","defaultValue","blockOverrides","childDir","parentBlockMatches","processedBlockNames","blockMatch","fullMatch","parentBlockContent","renderedParentContent","blockReplacement","overrideWithSuper","childOnlyBlocks","renderedChildBlock","templateRef","fromDir","replacer","replacementPromises","lastIndex","matchIndex","resolvePath","basePath","dirname","filePath","YAPL","templateDir"],"mappings":"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"}