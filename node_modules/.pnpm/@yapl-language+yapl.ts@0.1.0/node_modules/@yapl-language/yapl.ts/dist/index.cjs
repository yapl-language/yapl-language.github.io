"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function D(h){const e=h.renderer.rules.fence,t=h.renderer.rules.code_block,s=h.renderer.rules.code_inline,n=i=>i.includes("{{")||i.includes("{%"),r=(i,c)=>i?.toLowerCase().includes("yapl")||n(c);h.renderer.rules.fence=(i,c,a,o,l)=>{const d=i[c],u=(d.info||"").trim(),p=d.content||"",f=e?e(i,c,a,o,l):l.renderToken(i,c,a);return r(u,p)?`<div v-pre>
${f}
</div>
`:f},h.renderer.rules.code_block=(i,c,a,o,l)=>{const u=i[c].content||"",p=t?t(i,c,a,o,l):l.renderToken(i,c,a);return n(u)?`<div v-pre>
${p}
</div>
`:p},h.renderer.rules.code_inline=(i,c,a,o,l)=>{const u=i[c].content||"",p=s?s(i,c,a,o,l):l.renderToken(i,c,a);return n(u)?`<span v-pre>${p}</span>`:p}}const v=/\{%-?\s*extends\s+"([^"]+)"\s*-?%\}/,B=/\{%-?\s*mixin\s+((?:"[^"]+"\s*,\s*)*"[^"]+")\s*-?%\}/g,P=/\{%-?\s*include\s+"([^"]+)"(?:\s+with\s+(\{[\s\S]*?\}))?\s*-?%\}/g,w=/\{%-?\s*block\s+([a-zA-Z0-9_:-]+)\s*-?%\}([\s\S]*?)\{%-?\s*endblock\s*-?%\}/g,C=/\{\{-?\s*([a-zA-Z0-9_.]+)(?:\s*\|\s*default\((?:"([^"]*)"|'([^']*)')\))?\s*-?\}\}/g,b=/\{\{-?\s*super\(\s*\)\s*-?\}\}/g;function m(h,e){return e.split(".").reduce((t,s)=>{if(t&&typeof t=="object"&&s in t)return t[s]},h)}function k(h,e){const t=h.trim(),s=t.match(/^(.+?)\s+and\s+(.+)$/);if(s){const[,o,l]=s;return k(o.trim(),e)&&k(l.trim(),e)}const n=t.match(/^(.+?)\s+or\s+(.+)$/);if(n){const[,o,l]=n;return k(o.trim(),e)||k(l.trim(),e)}const r=t.match(/^(.+?)\s+is\s+(not\s+)?defined$/);if(r){const[,o,l]=r,d=m(e,o.trim()),u=d!=null;return l?!u:u}const i=t.match(/^(.+?)\s+is\s+(not\s+)?empty$/);if(i){const[,o,l]=i,d=m(e,o.trim()),u=d==null||d===""||Array.isArray(d)&&d.length===0||typeof d=="object"&&Object.keys(d).length===0;return l?!u:u}const c=t.match(/^(.+?)\s*(==|!=)\s*(.+)$/);if(c){const[,o,l,d]=c,u=E(o.trim(),e),p=E(d.trim(),e);if(l==="==")return u===p;if(l==="!=")return u!==p}return t.match(/^[a-zA-Z0-9_.]+$/)?!!m(e,t):!1}function E(h,e){const t=h.trim();return t.startsWith('"')&&t.endsWith('"')||t.startsWith("'")&&t.endsWith("'")?t.slice(1,-1):/^-?\d+(\.\d+)?$/.test(t)?Number(t):t==="true"?!0:t==="false"?!1:t==="null"?null:m(e,t)}function T(h){return(h.match(/"([^"]+)"/g)||[]).map(t=>t.slice(1,-1))}function S(h,e){const t=[],s=h.trim().replace(/^\{|\}$/g,"");if(!s.trim())return{};const n=[];let r="",i=null,c=!1;for(const o of s){if(i){if(c){r+=o,c=!1;continue}if(o==="\\"){r+=o,c=!0;continue}if(o===i){i=null,r+=o;continue}r+=o;continue}if(o==='"'||o==="'"){i=o,r+=o;continue}if(o===","){n.push(r.trim()),r="";continue}r+=o}r.trim()&&n.push(r.trim());for(const o of n){const l=o.match(/^\s*("?)([A-Za-z0-9_.-]+)\1\s*:\s*(.+)\s*$/);if(!l)continue;const d=l[2],u=l[3];t.push({k:d,v:u})}const a={};for(const{k:o,v:l}of t){const d=l.trim();if(d.startsWith('"')&&d.endsWith('"')||d.startsWith("'")&&d.endsWith("'")){a[o]=d.slice(1,-1);continue}if(/^-?\d+(\.\d+)?$/.test(d)){a[o]=Number(d);continue}if(d==="true"){a[o]=!0;continue}if(d==="false"){a[o]=!1;continue}if(d==="null"){a[o]=null;continue}a[o]=m(e,d)}return a}function g(h){const e=h.replace(/^\n/,"").replace(/\n\s*$/,"").split(`
`),t=e.filter(r=>r.trim().length>0);if(t.length===0)return h;const s=t.map(r=>{const i=r.match(/^[ \t]*/);return i?i[0].length:0}),n=Math.min(...s);return e.map(r=>r.slice(n)).join(`
`)}function I(h){let e=h;return e=e.replace(/[ \t]*\{\{-/g,"{{"),e=e.replace(/[ \t]*\{%-/g,"{%"),e=e.replace(/-\}\}[ \t]*\r?\n?/g,"}}"),e=e.replace(/-%\}[ \t]*\r?\n?/g,"%}"),e}function M(h,e){let t=h;return e.lstripBlocks&&(t=t.replace(/^[ \t]+(?=\{%)/gm,"")),e.trimBlocks&&(t=t.replace(/%\}[ \t]*\r?\n/g,"%}")),t}class x{constructor(e={}){this.baseDir=e.baseDir?e.baseDir:"",this.strictPaths=e.strictPaths!==!1,this.maxDepth=e.maxDepth??20,this.whitespaceOptions={trimBlocks:e.whitespace?.trimBlocks??!0,lstripBlocks:e.whitespace?.lstripBlocks??!0,dedentBlocks:e.whitespace?.dedentBlocks??!0},this.resolvePath=e.resolvePath,this.loadFile=e.loadFile,this.ensureExtension=e.ensureExtension??(t=>t.endsWith(".yapl")?t:`${t}.yapl`)}setBaseDir(e){this.baseDir=e}async renderString(e,t={},s){const n=new Set;return{content:await this.processTemplate(e,{vars:t,currentDir:s??this.baseDir,usedFiles:n,depth:0}),usedFiles:Array.from(n)}}async processTemplate(e,t,s){if(t.depth>this.maxDepth)throw new Error("Max template depth exceeded (possible recursion).");let n=I(e);if(n=M(n,this.whitespaceOptions),!s?.noExtends){const l=this.extractDirective(n,v);if(l)return await this.processTemplateInheritance(n,t,l[1])}const r=this.stripDirectives(n,[v,B]),i=await this.processDirectives(r,t,P,this.processIncludeDirective.bind(this)),c=await this.processStandaloneBlocks(i,t),a=await this.processIfElseStatements(c,t),o=this.stripDirectives(a,[b]);return this.processVariableInterpolation(o,t.vars)}async processTemplateInheritance(e,t,s){const n=this.resolveTemplatePath(s,t.currentDir),r=await this.loadTemplateFile(n);t.usedFiles.add(n);const i=this.extractBlockDefinitions(r),c=await this.collectBlocksFromMixins(e,t),a=this.extractBlockDefinitions(e),o=this.mergeBlocksWithSuper(c,i),l=this.mergeBlocksWithSuper(a,o);return await this.applyBlockOverridesToParent(r,l,{...t,depth:t.depth+1},t.currentDir)}extractDirective(e,t){return e.match(t)}stripDirectives(e,t){return t.reduce((s,n)=>s.replace(n,""),e)}async processDirectives(e,t,s,n){return await this.replaceAsync(e,s,async(...r)=>await n(r,t))}async processIncludeDirective(e,t){const[,s,n]=e,r=this.resolveTemplatePath(s,t.currentDir),i=await this.loadTemplateFile(r);t.usedFiles.add(r);const c=n?S(n,t.vars):{},a={...t.vars,...c};return await this.processTemplate(i,{vars:a,currentDir:this.dirname(r),usedFiles:t.usedFiles,depth:t.depth+1})}async processStandaloneBlocks(e,t){return await this.replaceAsync(e,w,async(s,n,r)=>{const i=this.whitespaceOptions.dedentBlocks?g(r):r;return await this.processTemplate(i,{...t,depth:t.depth+1},{noExtends:!0})})}extractBlockDefinitions(e){const t={},s=Array.from(e.matchAll(w));for(const n of s){const[,r,i]=n,c=this.whitespaceOptions.dedentBlocks?g(i):i;t[r]=c}return t}async collectBlocksFromMixins(e,t){const s=Array.from(e.matchAll(B)),n={};if(s.length===0)return n;for(const r of s){const i=T(r[1]);for(const c of i){const a=this.resolveTemplatePath(c,t.currentDir),o=await this.loadTemplateFile(a);t.usedFiles.add(a);const l=this.extractBlockDefinitions(o);this.mergeBlocksInto(n,l)}}return n}mergeBlocksInto(e,t){for(const[s,n]of Object.entries(t))e[s]=n}mergeBlocksWithSuper(e,t){const s={...t};for(const[n,r]of Object.entries(e)){const i=t[n]??"";s[n]=r.replace(b,i)}return s}async processIfElseStatements(e,t){return await this.processNestedIfStatements(e,t)}async processNestedIfStatements(e,t){let s=e;const n=50;let r=0;for(;r<n;){const i=await this.processSingleIfStatement(s,t);if(i===s)break;s=i,r++}return s}async processSingleIfStatement(e,t){const s=e.match(/\{%-?\s*if\s+([^%]+?)\s*-?%\}/);if(!s)return e;const n=s.index??0,r=s[1],{endifIndex:i,ifContent:c,elseContent:a}=this.findMatchingEndif(e,n);if(i===-1)return e;const o=k(r,t.vars);let l;if(o){const p=this.whitespaceOptions.dedentBlocks?g(c):c;l=await this.processTemplate(p,{...t,depth:t.depth+1},{noExtends:!0})}else if(a!==null){const p=this.whitespaceOptions.dedentBlocks?g(a):a;l=await this.processTemplate(p,{...t,depth:t.depth+1},{noExtends:!0})}else l="";const d=e.indexOf("%}",i)+2,u=e.slice(n,d);return e.replace(u,l)}findMatchingEndif(e,t){let s=0,n=null,r=0,i=e.indexOf("%}",t)+2;for(;i<e.length;){const c=e.slice(i).match(/\{%-?\s*(if|else|endif)/);if(!c)break;const a=i+(c.index??0),o=c[1];if(o==="if")s++,i=e.indexOf("%}",a)+2;else if(o==="else"&&s===0&&n===null){n=a;const l=e.indexOf("%}",a)+2;r=l-a,i=l}else if(o==="endif"){if(s===0){const l=e.indexOf("%}",t)+2,d=e.slice(l,n||a),u=n?e.slice(n+r,a):null;return{endifIndex:a,elseIndex:n,ifContent:d,elseContent:u}}s--,i=e.indexOf("%}",a)+2}else i=e.indexOf("%}",a)+2}return{endifIndex:-1,elseIndex:null,ifContent:"",elseContent:null}}processVariableInterpolation(e,t){return e.replace(C,(s,n,r,i)=>{const c=m(t,n),a=r??i;return c==null?a??"":String(c)})}async applyBlockOverridesToParent(e,t,s,n){let r=e;const i=Array.from(e.matchAll(w)),c=new Set;for(const o of i){const[l,d,u]=o;c.add(d);const p=await this.processTemplate(u,{...s,depth:s.depth+1},{noExtends:!0});let f;if(t[d]!==void 0){const y=t[d].replace(b,p);f=await this.processTemplate(y,{vars:s.vars,currentDir:n,usedFiles:s.usedFiles,depth:s.depth+1},{noExtends:!0})}else f=p;r=r.replace(l,f)}r=await this.processTemplate(r,s,{noExtends:!0});const a=[];for(const[o,l]of Object.entries(t))if(!c.has(o)){const d=await this.processTemplate(l,{vars:s.vars,currentDir:n,usedFiles:s.usedFiles,depth:s.depth+1},{noExtends:!0});a.push(d)}return a.length>0&&(r+=`
${a.join(`
`)}`),r}resolveTemplatePath(e,t){if(!this.resolvePath)throw new Error("No resolvePath provided. File-based operations are not available in this environment.");return this.resolvePath(this.ensureExtension(e),t,this.ensureExtension)}async loadTemplateFile(e){if(!this.loadFile)throw new Error("No loadFile provided. File-based operations are not available in this environment.");return await this.loadFile(e)}dirname(e){const t=e.replace(/\\/g,"/").lastIndexOf("/");return t>=0?e.slice(0,t):""}async replaceAsync(e,t,s){const n=[];let r=0;for(const c of e.matchAll(t)){const a=c.index??0;n.push(Promise.resolve(e.slice(r,a))),n.push(s(...c)),r=a+c[0].length}return n.push(Promise.resolve(e.slice(r))),(await Promise.all(n)).join("")}}class F{constructor(e){this.baseDir=(void 0)(e.baseDir),this.renderer=new x({baseDir:this.baseDir,maxDepth:e.maxDepth,whitespace:e.whitespace})}setBaseDir(e){this.baseDir=(void 0)(e),this.renderer.setBaseDir(this.baseDir)}async renderString(e,t={},s){return await this.renderer.renderString(e,t,s?(void 0)(s):this.baseDir)}async render(e,t={}){throw new Error("loadTemplateFile is not available in the browser. Use renderString for browser usage.")}}exports.YAPL=F;exports.protectYaplPlugin=D;
//# sourceMappingURL=index.cjs.map
